drop extension if exists "pg_net";

create sequence "public"."login_logs_id_seq";


  create table "public"."expiration_options" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "days" integer,
    "is_permanent" boolean default false,
    "sort_order" integer default 0,
    "hours" integer
      );


alter table "public"."expiration_options" enable row level security;


  create table "public"."link_access_logs" (
    "id" bigint generated by default as identity not null,
    "link_id" bigint not null,
    "accessed_at" timestamp with time zone not null default now(),
    "ip_address" text,
    "user_agent" text,
    "referrer" text,
    "country" text,
    "city" text,
    "device_type" text,
    "browser" text,
    "os" text
      );


alter table "public"."link_access_logs" enable row level security;


  create table "public"."login_logs" (
    "id" bigint not null default nextval('public.login_logs_id_seq'::regclass),
    "user_id" uuid,
    "email" text not null,
    "ip_address" text,
    "user_agent" text,
    "success" boolean not null default false,
    "failure_reason" text,
    "login_method" text not null default 'email'::text,
    "login_at" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."login_logs" enable row level security;


  create table "public"."user_identities" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "provider" text not null,
    "provider_user_id" text not null,
    "provider_email" text,
    "provider_metadata" jsonb default '{}'::jsonb,
    "linked_at" timestamp with time zone not null default now()
      );


alter table "public"."user_identities" enable row level security;


  create table "public"."user_profiles" (
    "id" uuid not null,
    "username" text,
    "avatar_url" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "is_admin" boolean default false
      );


alter table "public"."user_profiles" enable row level security;

alter table "public"."links" add column "access_restrictions" jsonb default '{}'::jsonb;

alter table "public"."links" add column "click_count" bigint default 0;

alter table "public"."links" add column "description" text;

alter table "public"."links" add column "expiration_date" timestamp without time zone;

alter table "public"."links" add column "forward_header_list" jsonb default '[]'::jsonb;

alter table "public"."links" add column "forward_headers" boolean default false;

alter table "public"."links" add column "is_active" boolean default true;

alter table "public"."links" add column "max_clicks" integer;

alter table "public"."links" add column "pass_query_params" boolean default false;

alter table "public"."links" add column "password_hash" text;

alter table "public"."links" add column "redirect_type" smallint default 302;

alter table "public"."links" add column "title" text;

alter table "public"."links" add column "updated_at" timestamp with time zone not null default now();

alter table "public"."links" add column "user_id" uuid;

alter table "public"."links" enable row level security;

alter sequence "public"."login_logs_id_seq" owned by "public"."login_logs"."id";

CREATE UNIQUE INDEX expiration_options_pkey ON public.expiration_options USING btree (id);

CREATE INDEX idx_link_access_logs_accessed_at ON public.link_access_logs USING btree (accessed_at DESC);

CREATE INDEX idx_link_access_logs_device_type ON public.link_access_logs USING btree (device_type);

CREATE INDEX idx_link_access_logs_link_id ON public.link_access_logs USING btree (link_id);

CREATE INDEX idx_links_created_at ON public.links USING btree (created_at DESC);

CREATE INDEX idx_links_expiration ON public.links USING btree (expiration_date) WHERE (expiration_date IS NOT NULL);

CREATE INDEX idx_links_is_active ON public.links USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_links_pass_query_params ON public.links USING btree (pass_query_params) WHERE (pass_query_params = true);

CREATE INDEX idx_links_redirect_type ON public.links USING btree (redirect_type);

CREATE INDEX idx_links_short ON public.links USING btree (short);

CREATE INDEX idx_links_user_id ON public.links USING btree (user_id);

CREATE INDEX idx_login_logs_email ON public.login_logs USING btree (email);

CREATE INDEX idx_login_logs_login_at ON public.login_logs USING btree (login_at DESC);

CREATE INDEX idx_login_logs_success ON public.login_logs USING btree (success);

CREATE INDEX idx_login_logs_user_id ON public.login_logs USING btree (user_id);

CREATE INDEX idx_user_identities_provider ON public.user_identities USING btree (provider);

CREATE INDEX idx_user_identities_user_id ON public.user_identities USING btree (user_id);

CREATE INDEX idx_user_profiles_username ON public.user_profiles USING btree (username);

CREATE UNIQUE INDEX link_access_logs_pkey ON public.link_access_logs USING btree (id);

CREATE UNIQUE INDEX links_short_unique ON public.links USING btree (short);

CREATE UNIQUE INDEX login_logs_pkey ON public.login_logs USING btree (id);

CREATE UNIQUE INDEX user_identities_pkey ON public.user_identities USING btree (id);

CREATE UNIQUE INDEX user_identities_provider_provider_user_id_key ON public.user_identities USING btree (provider, provider_user_id);

CREATE UNIQUE INDEX user_identities_user_id_provider_key ON public.user_identities USING btree (user_id, provider);

CREATE UNIQUE INDEX user_profiles_pkey ON public.user_profiles USING btree (id);

CREATE UNIQUE INDEX user_profiles_username_key ON public.user_profiles USING btree (username);

alter table "public"."expiration_options" add constraint "expiration_options_pkey" PRIMARY KEY using index "expiration_options_pkey";

alter table "public"."link_access_logs" add constraint "link_access_logs_pkey" PRIMARY KEY using index "link_access_logs_pkey";

alter table "public"."login_logs" add constraint "login_logs_pkey" PRIMARY KEY using index "login_logs_pkey";

alter table "public"."user_identities" add constraint "user_identities_pkey" PRIMARY KEY using index "user_identities_pkey";

alter table "public"."user_profiles" add constraint "user_profiles_pkey" PRIMARY KEY using index "user_profiles_pkey";

alter table "public"."link_access_logs" add constraint "link_access_logs_link_id_fkey" FOREIGN KEY (link_id) REFERENCES public.links(id) ON DELETE CASCADE not valid;

alter table "public"."link_access_logs" validate constraint "link_access_logs_link_id_fkey";

alter table "public"."links" add constraint "chk_redirect_type" CHECK ((redirect_type = ANY (ARRAY[301, 302, 307, 308]))) not valid;

alter table "public"."links" validate constraint "chk_redirect_type";

alter table "public"."links" add constraint "links_short_unique" UNIQUE using index "links_short_unique";

alter table "public"."links" add constraint "links_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."links" validate constraint "links_user_id_fkey";

alter table "public"."login_logs" add constraint "login_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."login_logs" validate constraint "login_logs_user_id_fkey";

alter table "public"."user_identities" add constraint "user_identities_provider_check" CHECK ((provider = ANY (ARRAY['email'::text, 'github'::text, 'google'::text]))) not valid;

alter table "public"."user_identities" validate constraint "user_identities_provider_check";

alter table "public"."user_identities" add constraint "user_identities_provider_provider_user_id_key" UNIQUE using index "user_identities_provider_provider_user_id_key";

alter table "public"."user_identities" add constraint "user_identities_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_identities" validate constraint "user_identities_user_id_fkey";

alter table "public"."user_identities" add constraint "user_identities_user_id_provider_key" UNIQUE using index "user_identities_user_id_provider_key";

alter table "public"."user_profiles" add constraint "user_profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_profiles" validate constraint "user_profiles_id_fkey";

alter table "public"."user_profiles" add constraint "user_profiles_username_key" UNIQUE using index "user_profiles_username_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_ip_in_cidr(ip_address text, cidr_list jsonb)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  cidr_item text;
BEGIN
  IF cidr_list IS NULL OR jsonb_array_length(cidr_list) = 0 THEN
    RETURN true;
  END IF;

  FOR cidr_item IN SELECT jsonb_array_elements_text(cidr_list)
  LOOP
    IF ip_address::inet <<= cidr_item::inet THEN
      RETURN true;
    END IF;
  END LOOP;

  RETURN false;
EXCEPTION
  WHEN OTHERS THEN
    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.clean_old_login_logs()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    DELETE FROM login_logs
    WHERE login_at < NOW() - INTERVAL '90 days';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_top_links_by_period(p_user_id uuid DEFAULT NULL::uuid, p_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 20)
 RETURNS TABLE(id bigint, short text, link text, click_count bigint, user_id uuid, created_at timestamp with time zone, is_active boolean, period_clicks bigint)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    l.id,
    l.short,
    l.link,
    l.click_count,
    l.user_id,
    l.created_at,
    l.is_active,
    COUNT(lal.id) AS period_clicks
  FROM
    links l
  LEFT JOIN
    link_access_logs lal ON l.id = lal.link_id
      AND (p_start_date IS NULL OR lal.accessed_at >= p_start_date)
  WHERE
    p_user_id IS NULL OR l.user_id = p_user_id
  GROUP BY
    l.id, l.short, l.link, l.click_count, l.user_id, l.created_at, l.is_active
  having 
    COUNT(lal.id) > 0
  ORDER BY
    period_clicks DESC,
    l.click_count DESC
  LIMIT
    p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_valid_link(short_code text, visitor_ip text DEFAULT NULL::text, visitor_device text DEFAULT NULL::text, visitor_referrer text DEFAULT NULL::text)
 RETURNS TABLE(id bigint, link text, redirect_type smallint, pass_query_params boolean, forward_headers boolean, forward_header_list jsonb, is_valid boolean, error_message text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  link_record record;
  restrictions jsonb;
  ip_whitelist jsonb;
  ip_blacklist jsonb;
  allowed_devices jsonb;
  allowed_referrers jsonb;
  blocked_referrers jsonb;
BEGIN
  -- 查询链接
  SELECT l.* INTO link_record
  FROM public.links l
  WHERE l.short = short_code;

  -- 链接不存在
  IF NOT FOUND THEN
    RETURN QUERY SELECT
      NULL::bigint, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
      false, '短链接不存在'::text;
    RETURN;
  END IF;

  -- 检查是否启用
  IF NOT link_record.is_active THEN
    RETURN QUERY SELECT
      link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
      false, '链接已被禁用'::text;
    RETURN;
  END IF;

  -- 检查是否过期
  IF link_record.expiration_date IS NOT NULL AND link_record.expiration_date < NOW() THEN
    RETURN QUERY SELECT
      link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
      false, '链接已过期'::text;
    RETURN;
  END IF;

  -- 检查点击次数限制
  IF link_record.max_clicks IS NOT NULL AND link_record.click_count >= link_record.max_clicks THEN
    RETURN QUERY SELECT
      link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
      false, '链接已达到最大访问次数'::text;
    RETURN;
  END IF;

  -- 获取访问限制配置
  restrictions := COALESCE(link_record.access_restrictions, '{}'::jsonb);

  -- IP 白名单检查
  ip_whitelist := restrictions->'ip_whitelist';
  IF ip_whitelist IS NOT NULL AND jsonb_array_length(ip_whitelist) > 0 AND visitor_ip IS NOT NULL THEN
    IF NOT public.check_ip_in_cidr(visitor_ip, ip_whitelist) THEN
      RETURN QUERY SELECT
        link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
        false, 'IP 地址不在允许范围内'::text;
      RETURN;
    END IF;
  END IF;

  -- IP 黑名单检查
  ip_blacklist := restrictions->'ip_blacklist';
  IF ip_blacklist IS NOT NULL AND jsonb_array_length(ip_blacklist) > 0 AND visitor_ip IS NOT NULL THEN
    IF public.check_ip_in_cidr(visitor_ip, ip_blacklist) THEN
      RETURN QUERY SELECT
        link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
        false, 'IP 地址已被禁止访问'::text;
      RETURN;
    END IF;
  END IF;

  -- 设备类型检查
  allowed_devices := restrictions->'allowed_devices';
  IF allowed_devices IS NOT NULL AND jsonb_array_length(allowed_devices) > 0 AND visitor_device IS NOT NULL THEN
    IF NOT (allowed_devices ? visitor_device) THEN
      RETURN QUERY SELECT
        link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
        false, '当前设备类型不允许访问'::text;
      RETURN;
    END IF;
  END IF;

  -- 来源限制检查（允许列表）
  allowed_referrers := restrictions->'allowed_referrers';
  IF allowed_referrers IS NOT NULL AND jsonb_array_length(allowed_referrers) > 0 AND visitor_referrer IS NOT NULL THEN
    -- 检查 referrer 是否在允许列表中
    DECLARE
      ref_item text;
      is_allowed boolean := false;
    BEGIN
      FOR ref_item IN SELECT jsonb_array_elements_text(allowed_referrers)
      LOOP
        IF visitor_referrer ILIKE '%' || ref_item || '%' THEN
          is_allowed := true;
          EXIT;
        END IF;
      END LOOP;

      IF NOT is_allowed THEN
        RETURN QUERY SELECT
          link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
          false, '访问来源不在允许范围内'::text;
        RETURN;
      END IF;
    END;
  END IF;

  -- 来源限制检查（禁止列表）
  blocked_referrers := restrictions->'blocked_referrers';
  IF blocked_referrers IS NOT NULL AND jsonb_array_length(blocked_referrers) > 0 AND visitor_referrer IS NOT NULL THEN
    DECLARE
      ref_item text;
    BEGIN
      FOR ref_item IN SELECT jsonb_array_elements_text(blocked_referrers)
      LOOP
        IF visitor_referrer ILIKE '%' || ref_item || '%' THEN
          RETURN QUERY SELECT
            link_record.id, NULL::text, NULL::smallint, NULL::boolean, NULL::boolean, NULL::jsonb,
            false, '访问来源已被禁止'::text;
          RETURN;
        END IF;
      END LOOP;
    END;
  END IF;

  -- 所有检查通过，返回有效链接
  RETURN QUERY SELECT
    link_record.id,
    link_record.link,
    link_record.redirect_type,
    link_record.pass_query_params,
    link_record.forward_headers,
    link_record.forward_header_list,
    true,
    NULL::text;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.user_profiles (id, username)
  values (
    new.id,
    new.raw_user_meta_data->>'username'
  );
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user_identity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- 从 auth.identities 表同步身份信息
  insert into public.user_identities (
    user_id,
    provider,
    provider_user_id,
    provider_email,
    provider_metadata
  )
  select
    new.id,
    i.provider,
    i.id,
    coalesce(i.identity_data->>'email', new.email),
    i.identity_data
  from auth.identities i
  where i.user_id = new.id
  on conflict (user_id, provider) do nothing;
  
  -- 如果有邮箱，确保有 email provider
  if new.email is not null then
    insert into public.user_identities (
      user_id,
      provider,
      provider_user_id,
      provider_email
    )
    values (
      new.id,
      'email',
      new.id::text,
      new.email
    )
    on conflict (user_id, provider) do nothing;
  end if;
  
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_click_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update public.links
  set click_count = click_count + 1
  where id = new.link_id;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_user_identities()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_record record;
  identity_record record;
begin
  -- 遍历所有用户
  for user_record in 
    select id, email, raw_app_meta_data, raw_user_meta_data
    from auth.users
  loop
    -- 从 auth.identities 表获取用户的所有身份
    for identity_record in
      select provider, id as provider_id, identity_data
      from auth.identities
      where user_id = user_record.id
    loop
      -- 插入或更新到 user_identities 表
      insert into public.user_identities (
        user_id,
        provider,
        provider_user_id,
        provider_email,
        provider_metadata
      )
      values (
        user_record.id,
        identity_record.provider,
        identity_record.provider_id,
        coalesce(
          identity_record.identity_data->>'email',
          user_record.email
        ),
        identity_record.identity_data
      )
      on conflict (user_id, provider) do update
      set
        provider_email = excluded.provider_email,
        provider_metadata = excluded.provider_metadata;
    end loop;
    
    -- 如果用户有邮箱但没有 email provider，添加一个
    if user_record.email is not null then
      insert into public.user_identities (
        user_id,
        provider,
        provider_user_id,
        provider_email
      )
      values (
        user_record.id,
        'email',
        user_record.id::text,
        user_record.email
      )
      on conflict (user_id, provider) do nothing;
    end if;
  end loop;
end;
$function$
;

grant delete on table "public"."expiration_options" to "anon";

grant insert on table "public"."expiration_options" to "anon";

grant references on table "public"."expiration_options" to "anon";

grant select on table "public"."expiration_options" to "anon";

grant trigger on table "public"."expiration_options" to "anon";

grant truncate on table "public"."expiration_options" to "anon";

grant update on table "public"."expiration_options" to "anon";

grant delete on table "public"."expiration_options" to "authenticated";

grant insert on table "public"."expiration_options" to "authenticated";

grant references on table "public"."expiration_options" to "authenticated";

grant select on table "public"."expiration_options" to "authenticated";

grant trigger on table "public"."expiration_options" to "authenticated";

grant truncate on table "public"."expiration_options" to "authenticated";

grant update on table "public"."expiration_options" to "authenticated";

grant delete on table "public"."expiration_options" to "service_role";

grant insert on table "public"."expiration_options" to "service_role";

grant references on table "public"."expiration_options" to "service_role";

grant select on table "public"."expiration_options" to "service_role";

grant trigger on table "public"."expiration_options" to "service_role";

grant truncate on table "public"."expiration_options" to "service_role";

grant update on table "public"."expiration_options" to "service_role";

grant delete on table "public"."link_access_logs" to "anon";

grant insert on table "public"."link_access_logs" to "anon";

grant references on table "public"."link_access_logs" to "anon";

grant select on table "public"."link_access_logs" to "anon";

grant trigger on table "public"."link_access_logs" to "anon";

grant truncate on table "public"."link_access_logs" to "anon";

grant update on table "public"."link_access_logs" to "anon";

grant delete on table "public"."link_access_logs" to "authenticated";

grant insert on table "public"."link_access_logs" to "authenticated";

grant references on table "public"."link_access_logs" to "authenticated";

grant select on table "public"."link_access_logs" to "authenticated";

grant trigger on table "public"."link_access_logs" to "authenticated";

grant truncate on table "public"."link_access_logs" to "authenticated";

grant update on table "public"."link_access_logs" to "authenticated";

grant delete on table "public"."link_access_logs" to "service_role";

grant insert on table "public"."link_access_logs" to "service_role";

grant references on table "public"."link_access_logs" to "service_role";

grant select on table "public"."link_access_logs" to "service_role";

grant trigger on table "public"."link_access_logs" to "service_role";

grant truncate on table "public"."link_access_logs" to "service_role";

grant update on table "public"."link_access_logs" to "service_role";

grant delete on table "public"."login_logs" to "anon";

grant insert on table "public"."login_logs" to "anon";

grant references on table "public"."login_logs" to "anon";

grant select on table "public"."login_logs" to "anon";

grant trigger on table "public"."login_logs" to "anon";

grant truncate on table "public"."login_logs" to "anon";

grant update on table "public"."login_logs" to "anon";

grant delete on table "public"."login_logs" to "authenticated";

grant insert on table "public"."login_logs" to "authenticated";

grant references on table "public"."login_logs" to "authenticated";

grant select on table "public"."login_logs" to "authenticated";

grant trigger on table "public"."login_logs" to "authenticated";

grant truncate on table "public"."login_logs" to "authenticated";

grant update on table "public"."login_logs" to "authenticated";

grant delete on table "public"."login_logs" to "service_role";

grant insert on table "public"."login_logs" to "service_role";

grant references on table "public"."login_logs" to "service_role";

grant select on table "public"."login_logs" to "service_role";

grant trigger on table "public"."login_logs" to "service_role";

grant truncate on table "public"."login_logs" to "service_role";

grant update on table "public"."login_logs" to "service_role";

grant delete on table "public"."user_identities" to "anon";

grant insert on table "public"."user_identities" to "anon";

grant references on table "public"."user_identities" to "anon";

grant select on table "public"."user_identities" to "anon";

grant trigger on table "public"."user_identities" to "anon";

grant truncate on table "public"."user_identities" to "anon";

grant update on table "public"."user_identities" to "anon";

grant delete on table "public"."user_identities" to "authenticated";

grant insert on table "public"."user_identities" to "authenticated";

grant references on table "public"."user_identities" to "authenticated";

grant select on table "public"."user_identities" to "authenticated";

grant trigger on table "public"."user_identities" to "authenticated";

grant truncate on table "public"."user_identities" to "authenticated";

grant update on table "public"."user_identities" to "authenticated";

grant delete on table "public"."user_identities" to "service_role";

grant insert on table "public"."user_identities" to "service_role";

grant references on table "public"."user_identities" to "service_role";

grant select on table "public"."user_identities" to "service_role";

grant trigger on table "public"."user_identities" to "service_role";

grant truncate on table "public"."user_identities" to "service_role";

grant update on table "public"."user_identities" to "service_role";

grant delete on table "public"."user_profiles" to "anon";

grant insert on table "public"."user_profiles" to "anon";

grant references on table "public"."user_profiles" to "anon";

grant select on table "public"."user_profiles" to "anon";

grant trigger on table "public"."user_profiles" to "anon";

grant truncate on table "public"."user_profiles" to "anon";

grant update on table "public"."user_profiles" to "anon";

grant delete on table "public"."user_profiles" to "authenticated";

grant insert on table "public"."user_profiles" to "authenticated";

grant references on table "public"."user_profiles" to "authenticated";

grant select on table "public"."user_profiles" to "authenticated";

grant trigger on table "public"."user_profiles" to "authenticated";

grant truncate on table "public"."user_profiles" to "authenticated";

grant update on table "public"."user_profiles" to "authenticated";

grant delete on table "public"."user_profiles" to "service_role";

grant insert on table "public"."user_profiles" to "service_role";

grant references on table "public"."user_profiles" to "service_role";

grant select on table "public"."user_profiles" to "service_role";

grant trigger on table "public"."user_profiles" to "service_role";

grant truncate on table "public"."user_profiles" to "service_role";

grant update on table "public"."user_profiles" to "service_role";


  create policy "任何人都可以插入访问日志"
  on "public"."link_access_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "链接所有者可以查看访问日志"
  on "public"."link_access_logs"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.links
  WHERE ((links.id = link_access_logs.link_id) AND (links.user_id = auth.uid())))));



  create policy "公开访问短链接"
  on "public"."links"
  as permissive
  for select
  to public
using (true);



  create policy "匿名用户可以创建短链接"
  on "public"."links"
  as permissive
  for insert
  to public
with check ((user_id IS NULL));



  create policy "用户只能删除自己的链接"
  on "public"."links"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "用户只能更新自己的链接"
  on "public"."links"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "用户查看自己的链接"
  on "public"."links"
  as permissive
  for select
  to public
using (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "认证用户可以创建短链接"
  on "public"."links"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Service role can insert any login log"
  on "public"."login_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "Service role can view all login logs"
  on "public"."login_logs"
  as permissive
  for select
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can view their own login logs"
  on "public"."login_logs"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "用户创建自己的身份绑定"
  on "public"."user_identities"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "用户删除自己的身份绑定"
  on "public"."user_identities"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "用户查看自己的身份绑定"
  on "public"."user_identities"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "用户可以插入自己的资料"
  on "public"."user_profiles"
  as permissive
  for insert
  to public
with check ((auth.uid() = id));



  create policy "用户可以更新自己的资料"
  on "public"."user_profiles"
  as permissive
  for update
  to public
using ((auth.uid() = id));



  create policy "用户可以查看自己的资料"
  on "public"."user_profiles"
  as permissive
  for select
  to public
using ((auth.uid() = id));


CREATE TRIGGER on_link_access AFTER INSERT ON public.link_access_logs FOR EACH ROW EXECUTE FUNCTION public.increment_click_count();

CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.links FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.user_profiles FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER on_auth_user_created_identity AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_identity();


